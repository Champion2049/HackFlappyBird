class FlappyBirdGame
{
  /*
  Models the Flappy Bird game at a high level by creating in-game objects,
  handling user inputs, and moving through game states.
  */

  field FlappyBird bird;                  // FlappyBird object.
  field Scoreboard scoreboard;            // Scoreboard object.
  field int bird_wing_state_count;        // Track Bird wing image angle.
  field int bird_fall_count;              // Track Bird's downward movement.
  field int bird_height_default;          // Default Bird starting height.
  field Array pipes;                      // Visible pipes on screen.
  field int count_pipes;                  // Number of pipes visible.
  field int dist_between_pipes;           // Interval between successive pipes.
  field int dist_after_last_pipe;         // Amount of space following last created pipe.
  field int jumps;                        // Number of jumps made in game.
  field int total_pipes;                  // Number of pipes created.
  field int highscore;                    // Highest score achieved in game.
  field int level;                        // Level of game.
  field int pipe_width;                   // Width of pipe. 
  field int pipe_gap;                     // Gap between top and bottom pipe.
  field Treat treat;                      // Treat object for power-ups.


  /*
  Flappy Bird Game constructor.
  */
  constructor FlappyBirdGame new() {
    let bird_height_default = 150;
    let scoreboard = Scoreboard.new();
    let pipes = Array.new(10);
    let count_pipes = 0;
    let dist_between_pipes = 100;
    let dist_after_last_pipe = 0;
    let jumps = 1;
    let total_pipes = 0;
    let highscore = 0;
    let pipe_width = 15;     // Default values for level 0
    let pipe_gap = 120;      // Default values for level 0
    let treat = Treat.new(); // Initialize the treat object
    return this;
  }

  /*
  Display instructions on the screen.
  */
  method void displayInstructions()
  {
    do Output.moveCursor(0, 0);
    do Output.printString("To Jump, press the space bar.");
    do Output.println();
    do Output.printString("To Quit, press the 'q' key.");
    do Output.println();
    do Output.printString("To win, stay alive.");
    do Output.println();
    do Output.printString("Remember to have fun!");
    do Output.println();
    do Output.printString("High Score: ");
    do Output.printInt(highscore);
    return;
  }

  /*
  Main loop for running game.
  */
  method void run() {
     var char key;
     var char last_key;
     var int score;

     do initializeGameState();
     do waitForGameToStart();
     let last_key = 32;
     while (~(key = 81)) { // 'q' key

        // Determine if new jump has occurred.
        if ((key = 32) & ~(last_key = 32)) {      // space bar
          let jumps = jumps + 1;
          do bird.moveUp();
        } else {
          do updateBirdFallState();
          do updateBirdWingState();
        }

        let score = calculateScore();     // Update score every frame
        do Sys.wait(2);             // Wait 2ms between frames
        do updateLevel(score);             // Update level based on current score
 
        // If collision found, go to score and reset state.
        if (findCollision()) {
          let score = calculateScore();
          if(score > highscore) {
            let highscore = score;
          }
          do displayScore();
          do Sys.wait(3000);
          let pipe_width = 15;     // Default values for level 0
          let pipe_gap = 120;      // Default values for level 0
          do initializeGameState();
          do waitForGameToStart();
        }

        // Draw updated game to screen.
        do draw();

        // Check key pressed.
        let last_key = key;
        let key = Keyboard.keyPressed();
        do Sys.wait(10);
    }

    return;
  }

  /*
  Animate Bird before game begins.
  */
  method void waitForGameToStart()
  {
    var char key;
    let key = Keyboard.keyPressed();

    while (key = 0) {
       do Sys.wait(10);
       let key = Keyboard.keyPressed();
       do bird.draw();
       do updateBirdWingState();
    }

    return;
  }

  /**
  * Update game level based on score.
  */
  method void updateLevel(int score)
  {
    if (score > 50) {
      let level = 3;
      let pipe_width = 40;
      let pipe_gap = 75;
    }
    if (score > 25) {
      let level = 2;
      let pipe_width = 35;
      let pipe_gap = 90;
    }
    if (score > 10) {
      let level = 1;
      let pipe_width = 25;
      let pipe_gap = 100;
    }
    else {
      let level = 0;
      let pipe_width = 15;
      let pipe_gap = 120;
    }

    return;
  }


  /*
  Set all fields to pre-game state.
  */
  method void initializeGameState()
  {
    var Pipe pipe;
    var int i;
    let i = 0;

    do whiteout();
    do displayInstructions();

    let bird = FlappyBird.new(bird_height_default);
    
    // Reset treat state
    if (~(treat = null)) {
        do treat.dispose();
    }
    let treat = Treat.new();

    // Remove existing pipes.
    while (i < count_pipes) {
      let pipe = pipes[i];
      do pipe.dispose();
      let i = i + 1;
    }

    let count_pipes = 0;
    let total_pipes = 0;
    let bird_wing_state_count = 1;
    let bird_fall_count = 1;
    let dist_after_last_pipe = dist_between_pipes;

    return;
  }

  /*
  White out screen.
  */
  method void whiteout()
  {
    do Screen.setColor(false);
    do Screen.drawRectangle(0, 0, 511, 255);

    return;
  }

  /*
  Display final score to screen.
  */
  method void displayScore()
  {
    var int score;
    let score = 0;

    let score = calculateScore();
    do scoreboard.draw(score);

    return;
  }

  /*
  Update bird's rising/falling status.
  */
  method void updateBirdFallState()
  {
    // Only move bird after a certain number of 'draw' cycles to prevent dropping too fast.
    // If treat 2 is active (slow down), bird falls more slowly
    var int fall_speed;
    
    let fall_speed = 5;
    if (treat.treatOn() = 2) {
        let fall_speed = 10; // Slower falling when slow down treat is active
    }
    
    if (bird_fall_count = fall_speed) {
      do bird.moveDown();
      let bird_fall_count = 1;
    } else {
      let bird_fall_count = bird_fall_count + 1;
    }

    return;
  }

  /*
  Update bird wing display state.
  */
  method void updateBirdWingState()
  {
    // Only cycle wings after every five 'draw' cycles to prevent changing too fast.
    if (bird_wing_state_count = 5) {
      do bird.cycleWingState();
      let bird_wing_state_count = 1;
    } else {
      let bird_wing_state_count = bird_wing_state_count + 1;
    }

    return;
  }

  /*
  Draw onscreen objects and update their coordinates.
  */
  method void draw()
  {
    var Pipe pipe;

    // Moves pipes left.
    do shiftPipesLeft();
    // Remove first pipe if no longer on screen.
    do disposeUnseenPipe();
    // Create new pipe object if existing last pipe has moved far enough.
    do createNewPipe();
    
    // Handle treat logic
    do spawnTreatIfNeeded();
    do treat.treatAdvance();
    do checkTreatCollision();
    do treat.timerTick();

    do bird.draw();

    return;
  }

  /* 
  Check if we should spawn a treat (if none is currently active)
  */
  method void spawnTreatIfNeeded() {
    var int randomNumber;
    
    // Only spawn a treat if none is coming
    if (treat.treatComing() = 0) {
        // Get a random number between 1-100
        let randomNumber = MyMath.mod(jumps + total_pipes + bird.getYOffset(), 100) + 1;
        
        // 3% chance to spawn a treat
        if (randomNumber < 3) {
            // Generate a random treat type (1-4)
            let randomNumber = MyMath.mod(jumps * bird.getYOffset() + total_pipes, 4) + 1;
            do treat.startComing(randomNumber);
            // Display what treat is coming
            do treat.writeExplain();
        }
    }
    
    return;
  }

  /*
  Check for collision between bird and treat
  */
  method void checkTreatCollision() {
    // Only check collision if a treat is coming and is near the bird
    if ((treat.treatComing() > 0) & (treat.treatAtBird() = 1)) {
        // If bird Y position overlaps with treat Y position
        if ((bird.getYOffset() < (treat.treatYpos() + 32)) & 
            ((bird.getYOffset() + bird.getSizeY()) > treat.treatYpos())) {
            // Treat was collected!
            do treat.treatGot();
        }
    }
    return;
  }

  /*
  Draw pipes and shift their coordinates to the left.
  */
  method void shiftPipesLeft()
  {
    var Pipe pipe;
    var int i;

    let i = 0;
    while (i < count_pipes) {
      let pipe = pipes[i];
      do pipe.draw();
      do pipe.moveLeft();
      let i = i + 1;
    }

    return;
  }

  /*
  Remove Pipe object once it has exited the screen.
  */
  method void disposeUnseenPipe()
  {
    var int i;
    var Pipe pipe;

    if (count_pipes = 0) {
      return;
    }

    let pipe = pipes[0];

    if (pipe.getWidthCurrent() < 1) {
      do pipe.dispose();
      let count_pipes = count_pipes - 1;
      let i = 0;
      while (i < count_pipes) {
        let pipes[i] = pipes[i+1];
        let i = i + 1;
      }
    }

    return;
  }

  /*
  Create new pipe to go onscreen.
  */
  method void createNewPipe()
  {
    var Pipe pipe;
    var int pipeMiddleY;

    if (dist_after_last_pipe = dist_between_pipes) {
      let pipes[count_pipes] = Pipe.new(jumps, pipe_width, pipe_gap);
      
      // Calculate the middle Y position of the pipe gap for treat placement
      let pipe = pipes[count_pipes];
      let pipeMiddleY = pipe.getGapTop() + (pipe_gap / 2) - 16; // Center treat in gap
      
      // Set the treat Y position to the middle of the gap
      do treat.setTreatYpos(pipeMiddleY);
      
      let count_pipes = count_pipes + 1;
      let total_pipes = total_pipes + 1;
      let dist_after_last_pipe = 0;
    } else {
      let pipe = pipes[0];
      let dist_after_last_pipe = dist_after_last_pipe + pipe.getWidthIncrement();
    }

    return;
  }

  /*
  Calculate final score.
  */
  method int calculateScore()
  {
    var Pipe pipe;
    var int i;
    var int score;

    let score = total_pipes;
    let i = 0;
    while (i < count_pipes) {
      let pipe = pipes[i];
      if (bird.getXOffset() < (pipe.getXOffset() + pipe.getWidthCurrent() + 1)) {
        let score = score - 1;
      }
      let i = i + 1;
    }

    // If treat 3 is active (score doubled), double the score
    if (treat.treatOn() = 3) {
      let score = score * 2;
    }

    return score;
  }

  /*
  Determine if there been a collision between bird and borders or pipes.
  */
  method boolean findCollision()
  {
    var Pipe pipe;
    var int i;
    // If treat 4 is active (helmet protection), bird is protected from collisions
    if (treat.treatOn() = 4) {
      return false;
    }
    
    // Has bird hit the top of the screen.
    if (bird.getYOffset() = 0) {
      return true;
    }

    // Has bird hit the bottom of the screen.
    if ((bird.getYOffset() + bird.getSizeY()) = 255) {
      return true;
    }
    let i = 0;
    while (i < count_pipes) {
      let pipe = pipes[i];
      if (collides(pipe)) {
        // If treat 1 is active (easy map), don't die from collisions
        if (treat.treatOn() = 1) {
          do treat.treatDone(); // Use up the treat
          return false;
        }
        return true;
      }
      let i = i + 1;
    }

    return false;
  }

  /*
  Has Bird collided with specific pipe.
  */
  method boolean collides(Pipe pipe)
  {
    // Is bird still in front of pipe.
    if (pipe.getXOffset() > (bird.getXOffset() + bird.getSizeX() + 1)) {
      return false;
    }

    // Has bird passed pipe.
    if ((pipe.getXOffset() + pipe.getWidthCurrent()) < bird.getXOffset()) {
      return false;
    }

    // Has bird hit top section of pipe.
    if (pipe.getGapTop() > bird.getYOffset()) {
      return true;
    }

    // Has bird hit bottom section of pipe.
    if (pipe.getGapBottom() < (bird.getYOffset() + bird.getSizeY())) {
      return true;
    }

    return false;
  }

  /*
  Dispose of FlappyBirdGame object and objects created as properties.
  */
  method void dispose() {
    var Pipe pipe;
    var int i;
    let i = 0;
    while (i < count_pipes) {
     let pipe = pipes[i];
     do pipe.dispose();
     let i = i + 1;
    }

    do scoreboard.dispose();
    do bird.dispose();
    do treat.dispose();

    do Memory.deAlloc(this);

    return;
  }
}